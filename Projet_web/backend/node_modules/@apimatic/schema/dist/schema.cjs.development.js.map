{"version":3,"file":"schema.cjs.development.js","sources":["../src/utils.ts","../src/schema.ts","../src/types/array.ts","../src/types/basic.ts","../src/types/defaults.ts","../src/types/dict.ts","../src/types/discriminatedObject.ts","../src/types/lazy.ts","../src/types/literal.ts","../src/types/nullable.ts","../src/types/numberEnum.ts","../src/types/object.ts","../src/types/optional.ts","../src/types/stringEnum.ts","../src/types/unknown.ts"],"sourcesContent":["/**\r\n * Utilities for internal library usage\r\n */\r\n\r\nimport { Schema, SchemaContextCreator, SchemaValidationError } from './schema';\r\n\r\nexport function arrayEntries<T>(arr: T[]) {\r\n  const entries: [number, T][] = [];\r\n  for (let index = 0; index < arr.length; index++) {\r\n    const element = arr[index];\r\n    entries.push([index, element]);\r\n  }\r\n  return entries;\r\n}\r\n\r\nexport function objectEntries<T extends Record<string, unknown>>(\r\n  obj: T\r\n): [Extract<keyof T, string>, T[keyof T]][] {\r\n  let ownProps = Object.keys(obj),\r\n    i = ownProps.length,\r\n    resArray = new Array(i); // preallocate the Array\r\n  while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n\r\n  return resArray;\r\n}\r\n\r\nexport function literalToString(value: any): string {\r\n  return typeof value === 'string'\r\n    ? `\"${value.replace(/\"/g, '\"')}\"`\r\n    : `${value}`;\r\n}\r\n\r\nexport function identityFn<T>(value: T): T {\r\n  return value;\r\n}\r\n\r\nexport function toValidator(\r\n  fn: (value: unknown) => boolean\r\n): (value: unknown, ctxt: SchemaContextCreator) => SchemaValidationError[] {\r\n  return (value, ctxt) => (fn(value) ? [] : ctxt.fail());\r\n}\r\n\r\n/**\r\n * Schema in which the mapping and unmapping is done the same way\r\n */\r\nexport interface SymmetricSchema<T> {\r\n  type: string;\r\n  validate: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: T, ctxt: SchemaContextCreator) => T;\r\n}\r\n\r\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\r\nexport function createSymmetricSchema<T>(\r\n  schema: SymmetricSchema<T>\r\n): Schema<T, T> {\r\n  return createBasicSchema({\r\n    type: () => schema.type,\r\n    validateBeforeMap: schema.validate,\r\n    validateBeforeUnmap: schema.validate,\r\n    map: schema.map,\r\n    unmap: schema.map,\r\n  });\r\n}\r\n\r\ninterface BasicSchema<T, S = unknown> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n}\r\n\r\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\r\nfunction createBasicSchema<T, S>(basicSchema: BasicSchema<T, S>): Schema<T, S> {\r\n  return {\r\n    ...basicSchema,\r\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\r\n    mapXml: basicSchema.map,\r\n    unmapXml: basicSchema.unmap,\r\n  };\r\n}\r\n\r\nexport function isNumericString(value: unknown): value is number | string {\r\n  return (\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && !isNaN(value as any))\r\n  );\r\n}\r\n\r\nexport function coerceNumericStringToNumber(value: number | string): number {\r\n  return typeof value === 'number' ? value : +value;\r\n}\r\n\r\nexport function coerceStringOrNumberToBigInt(\r\n  value: bigint | string | number\r\n): bigint {\r\n  return typeof value === 'bigint' ? value : BigInt(value);\r\n}\r\n\r\nexport function once<Args extends any[], R>(\r\n  func: (...args: Args) => R\r\n): (...args: Args) => R {\r\n  var ran = false,\r\n    memo: R;\r\n  return function(this: any, ...args) {\r\n    if (ran) return memo;\r\n    ran = true;\r\n    memo = func.apply(this, args);\r\n    return memo;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\r\nexport function omitKeysFromObject(\r\n  object: Record<string, unknown>,\r\n  keysToOmit: string[]\r\n): Record<string, unknown> {\r\n  const omitSet = new Set(keysToOmit);\r\n  const output: Record<string, unknown> = {};\r\n  for (const key in object) {\r\n    if (\r\n      Object.prototype.hasOwnProperty.call(object, key) &&\r\n      !omitSet.has(key)\r\n    ) {\r\n      output[key] = object[key];\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\nexport function objectKeyEncode(key: string): string {\r\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\r\n}\r\n","import flatten from 'lodash.flatten';\r\nimport { objectKeyEncode } from './utils';\r\n\r\n/**\r\n * Schema defines a type and its validation and mapping functions.\r\n */\r\nexport interface Schema<T, S = any> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n\r\n  validateBeforeMapXml: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  mapXml: (value: any, ctxt: SchemaContextCreator) => T;\r\n  unmapXml: (value: T, ctxt: SchemaContextCreator) => any;\r\n}\r\n\r\n/**\r\n * Type for a Schema\r\n */\r\nexport type SchemaType<T extends Schema<any, any>> = ReturnType<T['map']>;\r\n\r\n/**\r\n * Mapped type for the Schema\r\n */\r\nexport type SchemaMappedType<T extends Schema<any, any>> = ReturnType<\r\n  T['unmap']\r\n>;\r\n\r\n/**\r\n * Schema context when validating or mapping\r\n */\r\nexport interface SchemaContext {\r\n  readonly value: unknown;\r\n  readonly type: string;\r\n  readonly branch: Array<unknown>;\r\n  readonly path: Array<string | number>;\r\n}\r\n\r\n/**\r\n * SchemaContextCreator provides schema context as well as utility methods for\r\n * interacting with the context from inside the validation or mapping methods.\r\n */\r\nexport interface SchemaContextCreator extends SchemaContext {\r\n  createChild<T, S extends Schema<any, any>>(\r\n    key: any,\r\n    value: T,\r\n    childSchema: S\r\n  ): SchemaContextCreator;\r\n  flatmapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R[]\r\n  ): R[];\r\n  mapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R\r\n  ): R[];\r\n  fail(message?: string): SchemaValidationError[];\r\n}\r\n\r\n/**\r\n * Validation result after running validation.\r\n */\r\nexport type ValidationResult<T> =\r\n  | { errors: false; result: T }\r\n  | { errors: SchemaValidationError[] };\r\n\r\n/**\r\n * Schema validation error\r\n */\r\nexport interface SchemaValidationError extends SchemaContext {\r\n  readonly message?: string;\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMap<T extends Schema<any, any>>(\r\n  value: SchemaMappedType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.map(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmap<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaMappedType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmap(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMapXml<T extends Schema<any, any>>(\r\n  value: unknown,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMapXml(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.mapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmapXml<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<unknown> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new schema context using the given value and type.\r\n */\r\nfunction createNewSchemaContext(value: unknown, type: string): SchemaContext {\r\n  return {\r\n    value,\r\n    type,\r\n    branch: [value],\r\n    path: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\r\nfunction createSchemaContextCreator(\r\n  currentContext: SchemaContext\r\n): SchemaContextCreator {\r\n  const createChildContext: SchemaContextCreator['createChild'] = (\r\n    key,\r\n    value,\r\n    childSchema\r\n  ) =>\r\n    createSchemaContextCreator({\r\n      value,\r\n      type: childSchema.type(),\r\n      branch: [...currentContext.branch, value],\r\n      path: [...currentContext.path, key],\r\n    });\r\n\r\n  const mapChildren: SchemaContextCreator['mapChildren'] = (\r\n    items,\r\n    itemSchema,\r\n    mapper\r\n  ) =>\r\n    items.map(item =>\r\n      mapper(item, createChildContext(item[0], item[1], itemSchema))\r\n    );\r\n\r\n  return {\r\n    ...currentContext,\r\n    createChild: createChildContext,\r\n    flatmapChildren: (...args) => flatten(mapChildren(...args)),\r\n    mapChildren: mapChildren,\r\n    fail: message => [\r\n      {\r\n        ...currentContext,\r\n        message: createErrorMessage(currentContext, message),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\nfunction createErrorMessage(ctxt: SchemaContext, message?: string): string {\r\n  const giveValue = JSON.stringify(ctxt.value, (_, value) =>\r\n    typeof value === 'bigint' ? value.toString() : value\r\n  );\r\n  message =\r\n    (message ??\r\n      `Expected value to be of type '${\r\n        ctxt.type\r\n      }' but found '${typeof ctxt.value}'.`) +\r\n    '\\n' +\r\n    `\\nGiven value: ${giveValue}` +\r\n    `\\nType: '${typeof ctxt.value}'` +\r\n    `\\nExpected type: '${ctxt.type}'`;\r\n\r\n  if (ctxt.path.length > 0) {\r\n    const pathString = ctxt.path\r\n      .map(value => objectKeyEncode(value.toString()))\r\n      .join(' › ');\r\n    message += `\\nPath: ${pathString}`;\r\n  }\r\n\r\n  return message;\r\n}\r\n","import { Schema } from '../schema';\r\nimport { arrayEntries } from '../utils';\r\n\r\nexport interface ArrayXmlOptions {\r\n  xmlItemName: string;\r\n}\r\n\r\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\r\nexport function array<T, S>(\r\n  itemsSchema: Schema<T, S>,\r\n  xmlOptions?: ArrayXmlOptions\r\n): Schema<T[], S[]> {\r\n  let arraySchema: Schema<T[], S[]>;\r\n  arraySchema = {\r\n    type: () => `Array<${itemsSchema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeUnmap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    map: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.map(v[1], childCtxt)\r\n      ),\r\n    unmap: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.unmap(v[1], childCtxt)\r\n      ),\r\n    mapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        items = value[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n      return ctxt.mapChildren(\r\n        arrayEntries(items as any[]),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.mapXml(v[1], childCtxt)\r\n      );\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const items = ctxt.mapChildren(\r\n        arrayEntries(value),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.unmapXml(v[1], childCtxt)\r\n      );\r\n      if (xmlOptions?.xmlItemName) {\r\n        return { [xmlOptions.xmlItemName]: items };\r\n      } else {\r\n        return items;\r\n      }\r\n    },\r\n    validateBeforeMapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        const errorMessage = `Expected array to be wrapped with XML element ${xmlOptions.xmlItemName}.`;\r\n        if (\r\n          typeof value !== 'object' ||\r\n          value === null ||\r\n          !(xmlOptions.xmlItemName in value)\r\n        ) {\r\n          return ctxt.fail(errorMessage);\r\n        }\r\n        items = (value as Record<string, unknown>)[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n\r\n      return Array.isArray(items)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(items),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMapXml(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail();\r\n    },\r\n  };\r\n  return arraySchema;\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  isNumericString,\r\n  toValidator,\r\n  coerceNumericStringToNumber,\r\n  coerceStringOrNumberToBigInt,\r\n} from '../utils';\r\n\r\nfunction isValidStringValue(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\n/** Create a string schema. */\r\nexport function string(): Schema<string, string> {\r\n  return createSymmetricSchema({\r\n    type: 'string',\r\n    validate: toValidator(isValidStringValue),\r\n    map: identityFn,\r\n  });\r\n}\r\n\r\n/** Create a number schema. */\r\nexport function number(): Schema<number, number> {\r\n  return createSymmetricSchema({\r\n    type: 'number',\r\n    validate: toValidator(isNumericString),\r\n    map: coerceNumericStringToNumber,\r\n  });\r\n}\r\n\r\nfunction isValidBooleanValue(value: unknown): boolean {\r\n  return (\r\n    typeof value === 'boolean' ||\r\n    (typeof value === 'string' && (value === 'true' || value === 'false'))\r\n  );\r\n}\r\n\r\n/** Create a boolean schema. */\r\nexport function boolean(): Schema<boolean, boolean> {\r\n  return createSymmetricSchema({\r\n    type: 'boolean',\r\n    validate: toValidator(isValidBooleanValue),\r\n    map: value => (typeof value === 'boolean' ? value : value === 'true'),\r\n  });\r\n}\r\n\r\nfunction isValidBigIntValue(value: unknown): value is bigint {\r\n  return (\r\n    typeof value === 'bigint' ||\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && /^-?\\d+$/.test(value))\r\n  );\r\n}\r\n\r\n/** Create a bigint schema */\r\nexport function bigint(): Schema<bigint, bigint> {\r\n  return createSymmetricSchema({\r\n    type: 'bigint',\r\n    validate: toValidator(isValidBigIntValue),\r\n    map: coerceStringOrNumberToBigInt,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { literalToString } from '../utils';\r\n\r\n/**\r\n * Create a 'defaults' schema.\r\n *\r\n * During mapping or unmapping, if the value is null or undefined, the schema\r\n * defaults to the 'defaultValue' specified in the schema.\r\n */\r\nexport function defaults<M, U, V extends M & U>(\r\n  schema: Schema<M, U>,\r\n  defaultValue: V\r\n): Schema<M, U> {\r\n  return {\r\n    type: () => `Defaults<${schema.type()},${literalToString(defaultValue)}>`,\r\n    validateBeforeMap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMap(v, ctxt),\r\n    validateBeforeUnmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeUnmap(v, ctxt),\r\n    map: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.map(v, ctxt),\r\n    unmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmap(v, ctxt),\r\n    validateBeforeMapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue)\r\n        ? []\r\n        : schema.validateBeforeMapXml(v, ctxt),\r\n    mapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.mapXml(v, ctxt),\r\n    unmapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmapXml(v, ctxt),\r\n  };\r\n}\r\n\r\nfunction shouldDefault<T, V extends T>(value: T, defaultValue: V) {\r\n  return value === null || value === undefined || value === defaultValue;\r\n}\r\n","import { Schema, SchemaContextCreator, SchemaValidationError } from '../schema';\r\nimport { objectEntries } from '../utils';\r\n\r\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\r\nexport function dict<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const validate = (\r\n    validateFn:\r\n      | 'validateBeforeMap'\r\n      | 'validateBeforeUnmap'\r\n      | 'validateBeforeMapXml',\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as Record<string, unknown>;\r\n    return ctxt.flatmapChildren(\r\n      objectEntries(valueObject),\r\n      itemSchema,\r\n      (v, childCtxt) => itemSchema[validateFn](v[1], childCtxt)\r\n    );\r\n  };\r\n\r\n  return {\r\n    type: () => `Record<string,${itemSchema.type()}>`,\r\n    validateBeforeMap: (...args) => validate('validateBeforeMap', ...args),\r\n    validateBeforeUnmap: (...args) => validate('validateBeforeUnmap', ...args),\r\n    map: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.map(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmap: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmap(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    validateBeforeMapXml: (...args) =>\r\n      validate('validateBeforeMapXml', ...args),\r\n    mapXml: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.mapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n  };\r\n}\r\n\r\nexport function dictWithXmlEntries<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const dictSchema = dict(itemSchema);\r\n  const modifiedSchema = { ...dictSchema };\r\n\r\n  modifiedSchema.unmapXml = (value, ctxt) => {\r\n    const output: Record<string, S> = dictSchema.unmapXml(value, ctxt);\r\n\r\n    // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\r\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\r\n    // \"entry\" is set later at the return.\r\n    const entries = objectEntries(output).map(([key, value]) => ({\r\n      $: { key },\r\n      _: value,\r\n    }));\r\n\r\n    return { entry: entries };\r\n  };\r\n\r\n  modifiedSchema.mapXml = (value, ctxt) => {\r\n    // Empty dictionary\r\n    if (!('entry' in value)) {\r\n      return {};\r\n    }\r\n\r\n    let { entry: entries } = value as {\r\n      entry: { $: { key: string }; _: unknown }[];\r\n    };\r\n\r\n    // For a single entry, the XML parser gives a single object instead of an array.\r\n    // Make it an array for easier handling.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Convert entry elements containing a key attribute and content to a dictionary.\r\n    const dictObj: Record<string, unknown> = {};\r\n    for (const item of entries) {\r\n      dictObj[item.$.key] = item._;\r\n    }\r\n\r\n    // Run validation on entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validatin\r\n    return dictSchema.mapXml(dictObj, ctxt);\r\n  };\r\n\r\n  modifiedSchema.validateBeforeMapXml = (value, ctxt) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n\r\n    // Empty dictionary case\r\n    if (!('entry' in value)) {\r\n      return [];\r\n    }\r\n\r\n    let entries = (value as { entry: object[] })['entry'];\r\n\r\n    // Non-repeating XML elements are passed as a single-object instead of an array of objects.\r\n    // We normalize this behavior of the XML parser.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Dictionary for all entries\r\n    const dictObj: Record<string, unknown> = {};\r\n\r\n    for (let index = 0; index < entries.length; index++) {\r\n      const entry = entries[index];\r\n      // Fail if entry is not an XML element object.\r\n      if (typeof entry !== 'object' || entry === null) {\r\n        return ctxt.fail('Expected \"entry\" to be an XML element.');\r\n      }\r\n\r\n      // Fail if entry does not have an attribute named key.\r\n      if (!('$' in entry) || !('key' in (entry as { $: object }).$)) {\r\n        return ctxt.fail(\r\n          'Expected \"entry\" element to have an attribute named \"key\".'\r\n        );\r\n      }\r\n\r\n      // Set entry in dictionary\r\n      const typedEntry = entry as { $: { key: string }; _: unknown };\r\n      dictObj[typedEntry.$.key] = typedEntry._;\r\n    }\r\n\r\n    // Check all entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validation\r\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\r\n  };\r\n\r\n  return modifiedSchema;\r\n}\r\n","import { Schema, SchemaMappedType, SchemaType } from '../schema';\r\nimport { objectEntries } from '../utils';\r\nimport { ObjectXmlOptions } from './object';\r\n\r\nexport function discriminatedObject<\r\n  TSchema extends Schema<any, any>,\r\n  TDiscrimProp extends keyof SchemaType<TSchema>,\r\n  TDiscrimMappedProp extends keyof SchemaMappedType<TSchema>,\r\n  TDiscrimMap extends Record<string, TSchema>\r\n>(\r\n  discriminatorMappedPropName: TDiscrimMappedProp,\r\n  discriminatorPropName: TDiscrimProp,\r\n  discriminatorMap: TDiscrimMap,\r\n  defaultDiscriminator: keyof TDiscrimMap,\r\n  xmlOptions?: ObjectXmlOptions\r\n): Schema<any, any> {\r\n  const schemaSelector = (\r\n    value: unknown,\r\n    discriminatorProp: string | TDiscrimProp | TDiscrimMappedProp,\r\n    isAttr: boolean = false\r\n  ) => {\r\n    if (\r\n      typeof value === 'object' &&\r\n      value !== null &&\r\n      ((isAttr && xmlObjectHasAttribute(value, discriminatorProp as string)) ||\r\n        (!isAttr && (discriminatorProp as string) in value))\r\n    ) {\r\n      const discriminatorValue = isAttr\r\n        ? (value as { $: Record<string, unknown> })['$'][\r\n            discriminatorProp as string\r\n          ]\r\n        : (value as Record<typeof discriminatorProp, unknown>)[\r\n            discriminatorProp\r\n          ];\r\n      if (\r\n        typeof discriminatorValue === 'string' &&\r\n        discriminatorValue in discriminatorMap\r\n      ) {\r\n        return discriminatorMap[discriminatorValue];\r\n      }\r\n    }\r\n    return discriminatorMap[defaultDiscriminator];\r\n  };\r\n  return {\r\n    type: () =>\r\n      `DiscriminatedUnion<${discriminatorPropName},[${objectEntries(\r\n        discriminatorMap\r\n      )\r\n        .map(([_, v]) => v.type)\r\n        .join(',')}]>`,\r\n    map: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmap(value, ctxt),\r\n    validateBeforeMap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).validateBeforeMap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).validateBeforeUnmap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    mapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmapXml(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).validateBeforeMapXml(value, ctxt),\r\n  };\r\n}\r\n\r\nfunction xmlObjectHasAttribute(value: object, prop: string): boolean {\r\n  return (\r\n    '$' in value &&\r\n    typeof (value as { $: unknown })['$'] === 'object' &&\r\n    (prop as string) in (value as { $: Record<string, unknown> })['$']\r\n  );\r\n}\r\n","import { Schema } from '../schema';\r\nimport { once } from '../utils';\r\n\r\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\r\nexport function lazy<T, V>(schemaFn: () => Schema<T, V>): Schema<T, V> {\r\n  const getSchema = once(schemaFn); // Memoize schema\r\n  return {\r\n    type: () => `Lazy<${getSchema().type()}>`,\r\n    map: (...args) => getSchema().map(...args),\r\n    unmap: (...args) => getSchema().unmap(...args),\r\n    validateBeforeMap: (...args) => getSchema().validateBeforeMap(...args),\r\n    validateBeforeUnmap: (...args) => getSchema().validateBeforeUnmap(...args),\r\n    mapXml: (...args) => getSchema().mapXml(...args),\r\n    unmapXml: (...args) => getSchema().unmapXml(...args),\r\n    validateBeforeMapXml: (...args) =>\r\n      getSchema().validateBeforeMapXml(...args),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, literalToString, toValidator } from '../utils';\r\n\r\n/**\r\n * Create a literal schema.\r\n *\r\n * This schema always unmaps/maps to the constant value provided in the schema,\r\n * regardless of the value being mapped/unmapped. The validation always passes.\r\n */\r\nexport function literal<T extends boolean>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends number>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends string>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T> {\r\n  const validate = (value: unknown): value is T => literalValue === value;\r\n  const map = () => literalValue;\r\n  return createSymmetricSchema({\r\n    type: `Literal<${literalToString(literalValue)}>`,\r\n    validate: toValidator(validate),\r\n    map: map,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Creates a nullable schema.\r\n *\r\n * The nullable schema allows null values or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function nullable<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | null, S | null> {\r\n  return {\r\n    type: () => `Nullable<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) => (value === null ? null : schema.map(value, ctxt)),\r\n    unmap: (value, ctxt) => (value === null ? null : schema.unmap(value, ctxt)),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === null ? null : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === null ? null : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  coerceNumericStringToNumber,\r\n  createSymmetricSchema,\r\n  isNumericString,\r\n  toValidator,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    isNumericString(value) &&\r\n    enumValues.includes(coerceNumericStringToNumber(value));\r\n}\r\n\r\n/**\r\n * Create a schema for a number enumeration.\r\n */\r\nexport function numberEnum<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .filter(v => typeof v === 'number')\r\n      .join(',')}>`,\r\n    map: coerceNumericStringToNumber as (value: unknown) => TEnumValue,\r\n    validate: validate,\r\n  });\r\n}\r\n","import {\r\n  Schema,\r\n  SchemaContextCreator,\r\n  SchemaMappedType,\r\n  SchemaType,\r\n  SchemaValidationError,\r\n} from '../schema';\r\nimport { OptionalizeObject } from '../typeUtils';\r\nimport {\r\n  literalToString,\r\n  objectEntries,\r\n  objectKeyEncode,\r\n  omitKeysFromObject,\r\n} from '../utils';\r\n\r\ntype AnyObjectSchema = Record<\r\n  string,\r\n  [string, Schema<any, any>, ObjectXmlOptions?]\r\n>;\r\n\r\ntype AllValues<T extends AnyObjectSchema> = {\r\n  [P in keyof T]: { key: P; value: T[P][0]; schema: T[P][1] };\r\n}[keyof T];\r\n\r\nexport type MappedObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [P in AllValues<T>['value']]: SchemaMappedType<\r\n      Extract<AllValues<T>, { value: P }>['schema']\r\n    >;\r\n  }\r\n>;\r\n\r\nexport type ObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [K in keyof T]: SchemaType<T[K][1]>;\r\n  }\r\n>;\r\n\r\nexport interface ObjectXmlOptions {\r\n  isAttr?: boolean;\r\n  xmlName?: string;\r\n}\r\n\r\nexport interface StrictObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n> extends Schema<ObjectType<T>, MappedObjectType<T>> {\r\n  readonly objectSchema: T;\r\n}\r\n\r\nexport interface ObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>\r\n  extends Schema<\r\n    ObjectType<T> & { [key: string]: unknown },\r\n    MappedObjectType<T> & { [key: string]: unknown }\r\n  > {\r\n  readonly objectSchema: T;\r\n}\r\n\r\n/**\r\n * Create a Strict Object type schema.\r\n *\r\n * A strict-object does not allow additional properties during mapping or\r\n * unmapping. Additional properties will result in a validation error.\r\n */\r\nexport function strictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, false, false);\r\n  schema.type = () =>\r\n    `StrictObject<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create an Expandable Object type schema.\r\n *\r\n * The object schema allows additional properties during mapping and unmapping. The\r\n * additional properties are copied over as is.\r\n */\r\nexport function expandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): ObjectSchema<V, T> {\r\n  return internalObject(objectSchema, true, true);\r\n}\r\n\r\n/**\r\n * Create an Object Type schema.\r\n *\r\n * The Object schema allows additional properties during mapping and unmapping\r\n * but discards them.\r\n */\r\nexport function object<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, true, false);\r\n  schema.type = () =>\r\n    `Object<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create a strict-object schema that extends an existing schema.\r\n */\r\nexport function extendStrictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return strictObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an object schema that extends an existing schema.\r\n */\r\nexport function extendExpandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: ObjectSchema<V, T>,\r\n  objectSchema: B\r\n): ObjectSchema<string, T & B> {\r\n  return expandoObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an Object schema that extends an existing object schema.\r\n */\r\nexport function extendObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return object({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Internal utility to create object schema with different options.\r\n */\r\nfunction internalObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  objectSchema: T,\r\n  skipValidateAdditionalProps: boolean,\r\n  mapAdditionalProps: boolean\r\n): StrictObjectSchema<V, T> {\r\n  const keys = Object.keys(objectSchema);\r\n  const reverseObjectSchema = createReverseObjectSchema<T>(objectSchema);\r\n  const xmlMappingInfo = getXmlPropMappingForObjectSchema(objectSchema);\r\n  const xmlObjectSchema = createXmlObjectSchema(objectSchema);\r\n  const reverseXmlObjectSchema = createReverseXmlObjectSchema(xmlObjectSchema);\r\n  return {\r\n    type: () => `Object<{${keys.map(objectKeyEncode).join(',')},...}>`,\r\n    validateBeforeMap: validateObject(\r\n      objectSchema,\r\n      'validateBeforeMap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    validateBeforeUnmap: validateObject(\r\n      reverseObjectSchema,\r\n      'validateBeforeUnmap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    map: mapObject(objectSchema, 'map', mapAdditionalProps),\r\n    unmap: mapObject(reverseObjectSchema, 'unmap', mapAdditionalProps),\r\n    validateBeforeMapXml: validateObjectBeforeMapXml(\r\n      objectSchema,\r\n      xmlMappingInfo,\r\n      skipValidateAdditionalProps\r\n    ),\r\n    mapXml: mapObjectFromXml(xmlObjectSchema, mapAdditionalProps),\r\n    unmapXml: unmapObjectToXml(reverseXmlObjectSchema, mapAdditionalProps),\r\n    objectSchema: objectSchema,\r\n  };\r\n}\r\n\r\nfunction validateObjectBeforeMapXml(\r\n  objectSchema: Record<string, [string, Schema<any>, ObjectXmlOptions?]>,\r\n  xmlMappingInfo: ReturnType<typeof getXmlPropMappingForObjectSchema>,\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const { elementsToProps, attributesToProps } = xmlMappingInfo;\r\n  return (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    // Validate all known elements and attributes using the schema\r\n    return [\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'child elements',\r\n        propTypePrefix: 'element',\r\n        valueTypeName: 'element',\r\n        propMapping: elementsToProps,\r\n        objectSchema,\r\n        valueObject: elements,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'attributes',\r\n        propTypePrefix: '@',\r\n        valueTypeName: 'element',\r\n        propMapping: attributesToProps,\r\n        objectSchema,\r\n        valueObject: attributes,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n    ];\r\n  };\r\n}\r\n\r\nfunction mapObjectFromXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(elementsSchema, 'mapXml', allowAdditionalProps);\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'mapXml',\r\n    false // Always false; additional attributes are handled differently below.\r\n  );\r\n\r\n  // These are later used to omit know attribute props from the attributes object\r\n  // so that the remaining props can be copied over as additional props.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    const output: Record<string, unknown> = {\r\n      ...mapAttributes(attributes, ctxt),\r\n      ...mapElements(elements, ctxt),\r\n    };\r\n\r\n    if (allowAdditionalProps) {\r\n      // Omit known attributes and copy the rest as additional attributes.\r\n      const additionalAttrs = omitKeysFromObject(attributes, attributeKeys);\r\n      if (Object.keys(additionalAttrs).length > 0) {\r\n        // These additional attrs are set in the '$' property by convention.\r\n        output['$'] = additionalAttrs;\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction unmapObjectToXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(\r\n    elementsSchema,\r\n    'unmapXml',\r\n    allowAdditionalProps\r\n  );\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'unmapXml',\r\n    false // Always false so that element props are not copied during mapping\r\n  );\r\n\r\n  // These are later used to omit attribute props from the value object so that they\r\n  // do not get mapped during element mapping, if the allowAdditionalProps is true.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    // Get additional attributes which are set in the '$' property by convention\r\n    const { $: attributes, ...rest } = value as {\r\n      $?: unknown;\r\n      [key: string]: unknown;\r\n    };\r\n\r\n    // Ensure 'attributes' is an object and non-null\r\n    const additionalAttributes =\r\n      typeof attributes === 'object' &&\r\n      attributes !== null &&\r\n      allowAdditionalProps\r\n        ? attributes\r\n        : {};\r\n\r\n    return {\r\n      ...mapElements(omitKeysFromObject(rest, attributeKeys), ctxt),\r\n      $: { ...additionalAttributes, ...mapAttributes(value, ctxt) },\r\n    };\r\n  };\r\n}\r\n\r\nfunction validateValueObject({\r\n  validationMethod,\r\n  propTypeName,\r\n  propTypePrefix,\r\n  valueTypeName,\r\n  propMapping,\r\n  objectSchema,\r\n  valueObject,\r\n  ctxt,\r\n  allowAdditionalProperties,\r\n}: {\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml';\r\n  propTypeName: string;\r\n  propTypePrefix: string;\r\n  valueTypeName: string;\r\n  propMapping: Record<string, string>;\r\n  objectSchema: AnyObjectSchema;\r\n  valueObject: { [key: string]: unknown };\r\n  ctxt: SchemaContextCreator;\r\n  allowAdditionalProperties: boolean;\r\n}) {\r\n  const errors: SchemaValidationError[] = [];\r\n  const missingProps: Set<string> = new Set();\r\n  const unknownProps: Set<string> = new Set(Object.keys(valueObject));\r\n\r\n  // Validate all known properties using the schema\r\n  for (const key in propMapping) {\r\n    const propName = propMapping[key];\r\n    const schema = objectSchema[propName][1];\r\n    unknownProps.delete(key);\r\n    if (key in valueObject) {\r\n      errors.push(\r\n        ...schema[validationMethod](\r\n          valueObject[key],\r\n          ctxt.createChild(propTypePrefix + key, valueObject[key], schema)\r\n        )\r\n      );\r\n    } else if (schema.type().indexOf('Optional<') !== 0) {\r\n      // Add to missing keys if it is not an optional property\r\n      missingProps.add(key);\r\n    }\r\n  }\r\n\r\n  // Create validation error for unknown properties encountered\r\n  const unknownPropsArray = Array.from(unknownProps);\r\n  if (unknownPropsArray.length > 0 && !allowAdditionalProperties) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some unknown ${propTypeName} were found in the ${valueTypeName}: ${unknownPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  // Create validation error for missing required properties\r\n  const missingPropsArray = Array.from(missingProps);\r\n  if (missingPropsArray.length > 0) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some ${propTypeName} are missing in the ${valueTypeName}: ${missingPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction validateObject(\r\n  objectSchema: AnyObjectSchema,\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const propsMapping = getPropMappingForObjectSchema(objectSchema);\r\n  return (value: unknown, ctxt: SchemaContextCreator) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    return validateValueObject({\r\n      validationMethod,\r\n      propTypeName: 'properties',\r\n      propTypePrefix: '',\r\n      valueTypeName: 'object',\r\n      propMapping: propsMapping,\r\n      objectSchema,\r\n      valueObject: value as Record<string, unknown>,\r\n      ctxt,\r\n      allowAdditionalProperties,\r\n    });\r\n  };\r\n}\r\n\r\nfunction mapObject<T extends AnyObjectSchema>(\r\n  objectSchema: T,\r\n  mappingFn: 'map' | 'unmap' | 'mapXml' | 'unmapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const output: Record<string, unknown> = {};\r\n    const objectValue = value as Record<string, any>;\r\n    /** Properties seen in the object but not in the schema */\r\n    const unknownKeys = new Set(Object.keys(objectValue));\r\n\r\n    // Map known properties using the schema\r\n    for (const key in objectSchema) {\r\n      /* istanbul ignore else */\r\n      if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n        const element = objectSchema[key];\r\n        const propName = element[0];\r\n        const propValue = objectValue[propName];\r\n        unknownKeys.delete(propName);\r\n\r\n        // Skip mapping for optional properties to avoid creating properties with value 'undefined'\r\n        if (\r\n          element[1].type().indexOf('Optional<') !== 0 ||\r\n          propValue !== undefined\r\n        ) {\r\n          output[key] = element[1][mappingFn](\r\n            propValue,\r\n            ctxt.createChild(propName, propValue, element[1])\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Copy unknown properties over if additional properties flag is set\r\n    if (allowAdditionalProperties) {\r\n      unknownKeys.forEach(unknownKey => {\r\n        output[unknownKey] = objectValue[unknownKey];\r\n      });\r\n    }\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction getXmlPropMappingForObjectSchema(objectSchema: AnyObjectSchema) {\r\n  const elementsToProps: Record<string, string> = {};\r\n  const attributesToProps: Record<string, string> = {};\r\n\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const [propName, , xmlOptions] = objectSchema[key];\r\n      if (xmlOptions?.isAttr === true) {\r\n        attributesToProps[xmlOptions.xmlName ?? propName] = key;\r\n      } else {\r\n        elementsToProps[xmlOptions?.xmlName ?? propName] = key;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { elementsToProps, attributesToProps };\r\n}\r\n\r\nfunction getPropMappingForObjectSchema(\r\n  objectSchema: AnyObjectSchema\r\n): Record<string, string> {\r\n  const propsMapping: Record<string, string> = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const propDef = objectSchema[key];\r\n      propsMapping[propDef[0]] = key;\r\n    }\r\n  }\r\n  return propsMapping;\r\n}\r\n\r\nfunction createReverseObjectSchema<T extends AnyObjectSchema>(\r\n  objectSchema: T\r\n): AnyObjectSchema {\r\n  const reverseObjectSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      reverseObjectSchema[element[0]] = [key, element[1], element[2]];\r\n    }\r\n  }\r\n  return reverseObjectSchema;\r\n}\r\n\r\ntype XmlObjectSchema = {\r\n  elementsSchema: AnyObjectSchema;\r\n  attributesSchema: AnyObjectSchema;\r\n};\r\n\r\nfunction createXmlObjectSchema(objectSchema: AnyObjectSchema): XmlObjectSchema {\r\n  const elementsSchema: AnyObjectSchema = {};\r\n  const attributesSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      const [serializedName, schema, xmlOptions] = element;\r\n      const xmlObjectSchema = xmlOptions?.isAttr\r\n        ? attributesSchema\r\n        : elementsSchema;\r\n      xmlObjectSchema[key] = [\r\n        xmlOptions?.xmlName ?? serializedName,\r\n        schema,\r\n        xmlOptions,\r\n      ];\r\n    }\r\n  }\r\n  return { elementsSchema, attributesSchema };\r\n}\r\n\r\nfunction createReverseXmlObjectSchema(\r\n  xmlObjectSchema: XmlObjectSchema\r\n): XmlObjectSchema {\r\n  return {\r\n    attributesSchema: createReverseObjectSchema(\r\n      xmlObjectSchema.attributesSchema\r\n    ),\r\n    elementsSchema: createReverseObjectSchema(xmlObjectSchema.elementsSchema),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Create an optional schema.\r\n *\r\n * The optional schema allows 'undefined' or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function optional<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | undefined, S | undefined> {\r\n  return {\r\n    type: () => `Optional<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmap(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  toValidator,\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  literalToString,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    typeof value === 'string' && enumValues.includes(value);\r\n}\r\n\r\n/**\r\n * Create a schema for a string enumeration.\r\n */\r\nexport function stringEnum<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .map(literalToString)\r\n      .join(',')}>`,\r\n    map: identityFn,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, identityFn } from '../utils';\r\n\r\n/**\r\n * Create an unknown schema.\r\n *\r\n * The unknown schema allows any value.\r\n */\r\nexport function unknown(): Schema<unknown, unknown> {\r\n  return createSymmetricSchema({\r\n    type: 'unknown',\r\n    validate: () => [],\r\n    map: identityFn,\r\n  });\r\n}\r\n"],"names":["arrayEntries","arr","entries","index","length","element","push","objectEntries","obj","ownProps","Object","keys","i","resArray","Array","literalToString","value","replace","identityFn","toValidator","fn","ctxt","fail","createSymmetricSchema","schema","createBasicSchema","type","validateBeforeMap","validate","validateBeforeUnmap","map","unmap","basicSchema","validateBeforeMapXml","mapXml","unmapXml","isNumericString","isNaN","coerceNumericStringToNumber","coerceStringOrNumberToBigInt","BigInt","once","func","ran","memo","args","apply","omitKeysFromObject","object","keysToOmit","omitSet","Set","output","key","prototype","hasOwnProperty","call","has","objectKeyEncode","indexOf","validateAndMap","contextCreator","createSchemaContextCreator","createNewSchemaContext","validationResult","errors","result","validateAndUnmap","validateAndMapXml","validateAndUnmapXml","branch","path","currentContext","createChildContext","childSchema","mapChildren","items","itemSchema","mapper","item","createChild","flatmapChildren","flatten","message","createErrorMessage","giveValue","JSON","stringify","_","toString","pathString","join","array","itemsSchema","xmlOptions","arraySchema","isArray","v","childCtxt","xmlItemName","errorMessage","isValidStringValue","string","number","isValidBooleanValue","boolean","isValidBigIntValue","test","bigint","defaults","defaultValue","shouldDefault","undefined","dict","validateFn","valueObject","propValue","dictWithXmlEntries","dictSchema","modifiedSchema","$","entry","dictObj","typedEntry","discriminatedObject","discriminatorMappedPropName","discriminatorPropName","discriminatorMap","defaultDiscriminator","schemaSelector","discriminatorProp","isAttr","xmlObjectHasAttribute","discriminatorValue","xmlName","prop","lazy","schemaFn","getSchema","literal","literalValue","nullable","createEnumChecker","enumVariable","enumValues","values","includes","numberEnum","filter","strictObject","objectSchema","internalObject","expandoObject","extendStrictObject","parentObjectSchema","extendExpandoObject","extendObject","skipValidateAdditionalProps","mapAdditionalProps","reverseObjectSchema","createReverseObjectSchema","xmlMappingInfo","getXmlPropMappingForObjectSchema","xmlObjectSchema","createXmlObjectSchema","reverseXmlObjectSchema","createReverseXmlObjectSchema","validateObject","mapObject","validateObjectBeforeMapXml","mapObjectFromXml","unmapObjectToXml","allowAdditionalProperties","elementsToProps","attributesToProps","attributes","elements","validateValueObject","validationMethod","propTypeName","propTypePrefix","valueTypeName","propMapping","allowAdditionalProps","elementsSchema","attributesSchema","mapElements","mapAttributes","attributeKeys","name","additionalAttrs","rest","additionalAttributes","missingProps","unknownProps","propName","add","unknownPropsArray","from","missingPropsArray","propsMapping","getPropMappingForObjectSchema","mappingFn","objectValue","unknownKeys","forEach","unknownKey","propDef","serializedName","optional","stringEnum","unknown"],"mappings":"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"}