{"version":3,"file":"schema.cjs.production.min.js","sources":["../src/utils.ts","../src/schema.ts","../src/types/basic.ts","../src/types/defaults.ts","../src/types/dict.ts","../src/types/object.ts","../src/types/array.ts","../src/types/discriminatedObject.ts","../src/types/lazy.ts","../src/types/literal.ts","../src/types/nullable.ts","../src/types/numberEnum.ts","../src/types/optional.ts","../src/types/stringEnum.ts","../src/types/unknown.ts"],"sourcesContent":["/**\r\n * Utilities for internal library usage\r\n */\r\n\r\nimport { Schema, SchemaContextCreator, SchemaValidationError } from './schema';\r\n\r\nexport function arrayEntries<T>(arr: T[]) {\r\n  const entries: [number, T][] = [];\r\n  for (let index = 0; index < arr.length; index++) {\r\n    const element = arr[index];\r\n    entries.push([index, element]);\r\n  }\r\n  return entries;\r\n}\r\n\r\nexport function objectEntries<T extends Record<string, unknown>>(\r\n  obj: T\r\n): [Extract<keyof T, string>, T[keyof T]][] {\r\n  let ownProps = Object.keys(obj),\r\n    i = ownProps.length,\r\n    resArray = new Array(i); // preallocate the Array\r\n  while (i--) resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n\r\n  return resArray;\r\n}\r\n\r\nexport function literalToString(value: any): string {\r\n  return typeof value === 'string'\r\n    ? `\"${value.replace(/\"/g, '\"')}\"`\r\n    : `${value}`;\r\n}\r\n\r\nexport function identityFn<T>(value: T): T {\r\n  return value;\r\n}\r\n\r\nexport function toValidator(\r\n  fn: (value: unknown) => boolean\r\n): (value: unknown, ctxt: SchemaContextCreator) => SchemaValidationError[] {\r\n  return (value, ctxt) => (fn(value) ? [] : ctxt.fail());\r\n}\r\n\r\n/**\r\n * Schema in which the mapping and unmapping is done the same way\r\n */\r\nexport interface SymmetricSchema<T> {\r\n  type: string;\r\n  validate: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: T, ctxt: SchemaContextCreator) => T;\r\n}\r\n\r\n/**\r\n * Create a schema in which the mapping and unmapping is done the same way\r\n */\r\nexport function createSymmetricSchema<T>(\r\n  schema: SymmetricSchema<T>\r\n): Schema<T, T> {\r\n  return createBasicSchema({\r\n    type: () => schema.type,\r\n    validateBeforeMap: schema.validate,\r\n    validateBeforeUnmap: schema.validate,\r\n    map: schema.map,\r\n    unmap: schema.map,\r\n  });\r\n}\r\n\r\ninterface BasicSchema<T, S = unknown> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n}\r\n\r\n/** Create a basic schema where XML mapping and validation is the same as for JSON */\r\nfunction createBasicSchema<T, S>(basicSchema: BasicSchema<T, S>): Schema<T, S> {\r\n  return {\r\n    ...basicSchema,\r\n    validateBeforeMapXml: basicSchema.validateBeforeUnmap,\r\n    mapXml: basicSchema.map,\r\n    unmapXml: basicSchema.unmap,\r\n  };\r\n}\r\n\r\nexport function isNumericString(value: unknown): value is number | string {\r\n  return (\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && !isNaN(value as any))\r\n  );\r\n}\r\n\r\nexport function coerceNumericStringToNumber(value: number | string): number {\r\n  return typeof value === 'number' ? value : +value;\r\n}\r\n\r\nexport function coerceStringOrNumberToBigInt(\r\n  value: bigint | string | number\r\n): bigint {\r\n  return typeof value === 'bigint' ? value : BigInt(value);\r\n}\r\n\r\nexport function once<Args extends any[], R>(\r\n  func: (...args: Args) => R\r\n): (...args: Args) => R {\r\n  var ran = false,\r\n    memo: R;\r\n  return function(this: any, ...args) {\r\n    if (ran) return memo;\r\n    ran = true;\r\n    memo = func.apply(this, args);\r\n    return memo;\r\n  };\r\n}\r\n\r\n/**\r\n * Returns a copy of the object with the given keys omitted.\r\n */\r\nexport function omitKeysFromObject(\r\n  object: Record<string, unknown>,\r\n  keysToOmit: string[]\r\n): Record<string, unknown> {\r\n  const omitSet = new Set(keysToOmit);\r\n  const output: Record<string, unknown> = {};\r\n  for (const key in object) {\r\n    if (\r\n      Object.prototype.hasOwnProperty.call(object, key) &&\r\n      !omitSet.has(key)\r\n    ) {\r\n      output[key] = object[key];\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\nexport function objectKeyEncode(key: string): string {\r\n  return key.indexOf(' ') !== -1 ? literalToString(key) : key;\r\n}\r\n","import flatten from 'lodash.flatten';\r\nimport { objectKeyEncode } from './utils';\r\n\r\n/**\r\n * Schema defines a type and its validation and mapping functions.\r\n */\r\nexport interface Schema<T, S = any> {\r\n  type: () => string;\r\n  validateBeforeMap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  validateBeforeUnmap: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  map: (value: S, ctxt: SchemaContextCreator) => T;\r\n  unmap: (value: T, ctxt: SchemaContextCreator) => S;\r\n\r\n  validateBeforeMapXml: (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ) => SchemaValidationError[];\r\n  mapXml: (value: any, ctxt: SchemaContextCreator) => T;\r\n  unmapXml: (value: T, ctxt: SchemaContextCreator) => any;\r\n}\r\n\r\n/**\r\n * Type for a Schema\r\n */\r\nexport type SchemaType<T extends Schema<any, any>> = ReturnType<T['map']>;\r\n\r\n/**\r\n * Mapped type for the Schema\r\n */\r\nexport type SchemaMappedType<T extends Schema<any, any>> = ReturnType<\r\n  T['unmap']\r\n>;\r\n\r\n/**\r\n * Schema context when validating or mapping\r\n */\r\nexport interface SchemaContext {\r\n  readonly value: unknown;\r\n  readonly type: string;\r\n  readonly branch: Array<unknown>;\r\n  readonly path: Array<string | number>;\r\n}\r\n\r\n/**\r\n * SchemaContextCreator provides schema context as well as utility methods for\r\n * interacting with the context from inside the validation or mapping methods.\r\n */\r\nexport interface SchemaContextCreator extends SchemaContext {\r\n  createChild<T, S extends Schema<any, any>>(\r\n    key: any,\r\n    value: T,\r\n    childSchema: S\r\n  ): SchemaContextCreator;\r\n  flatmapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R[]\r\n  ): R[];\r\n  mapChildren<K extends string | number, T, S extends Schema<any, any>, R>(\r\n    items: [K, T][],\r\n    itemSchema: S,\r\n    mapper: (item: [K, T], childCtxt: SchemaContextCreator) => R\r\n  ): R[];\r\n  fail(message?: string): SchemaValidationError[];\r\n}\r\n\r\n/**\r\n * Validation result after running validation.\r\n */\r\nexport type ValidationResult<T> =\r\n  | { errors: false; result: T }\r\n  | { errors: SchemaValidationError[] };\r\n\r\n/**\r\n * Schema validation error\r\n */\r\nexport interface SchemaValidationError extends SchemaContext {\r\n  readonly message?: string;\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after JSON deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMap<T extends Schema<any, any>>(\r\n  value: SchemaMappedType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.map(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before JSON serializatin.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmap<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<SchemaMappedType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmap(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Validate and map the value using the given schema.\r\n *\r\n * This method should be used after XML deserialization.\r\n *\r\n * @param value Value to map\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndMapXml<T extends Schema<any, any>>(\r\n  value: unknown,\r\n  schema: T\r\n): ValidationResult<SchemaType<T>> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeMapXml(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.mapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Valudate and unmap the value using the given schema.\r\n *\r\n * This method should be used before XML serialization.\r\n *\r\n * @param value Value to unmap\r\n * @param schema Schema for type\r\n */\r\nexport function validateAndUnmapXml<T extends Schema<any, any>>(\r\n  value: SchemaType<T>,\r\n  schema: T\r\n): ValidationResult<unknown> {\r\n  const contextCreator = createSchemaContextCreator(\r\n    createNewSchemaContext(value, schema.type())\r\n  );\r\n  const validationResult = schema.validateBeforeUnmap(value, contextCreator);\r\n  if (validationResult.length === 0) {\r\n    return { errors: false, result: schema.unmapXml(value, contextCreator) };\r\n  } else {\r\n    return { errors: validationResult };\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new schema context using the given value and type.\r\n */\r\nfunction createNewSchemaContext(value: unknown, type: string): SchemaContext {\r\n  return {\r\n    value,\r\n    type,\r\n    branch: [value],\r\n    path: [],\r\n  };\r\n}\r\n\r\n/**\r\n * Create a new SchemaContextCreator for the given SchemaContext.\r\n */\r\nfunction createSchemaContextCreator(\r\n  currentContext: SchemaContext\r\n): SchemaContextCreator {\r\n  const createChildContext: SchemaContextCreator['createChild'] = (\r\n    key,\r\n    value,\r\n    childSchema\r\n  ) =>\r\n    createSchemaContextCreator({\r\n      value,\r\n      type: childSchema.type(),\r\n      branch: [...currentContext.branch, value],\r\n      path: [...currentContext.path, key],\r\n    });\r\n\r\n  const mapChildren: SchemaContextCreator['mapChildren'] = (\r\n    items,\r\n    itemSchema,\r\n    mapper\r\n  ) =>\r\n    items.map(item =>\r\n      mapper(item, createChildContext(item[0], item[1], itemSchema))\r\n    );\r\n\r\n  return {\r\n    ...currentContext,\r\n    createChild: createChildContext,\r\n    flatmapChildren: (...args) => flatten(mapChildren(...args)),\r\n    mapChildren: mapChildren,\r\n    fail: message => [\r\n      {\r\n        ...currentContext,\r\n        message: createErrorMessage(currentContext, message),\r\n      },\r\n    ],\r\n  };\r\n}\r\n\r\nfunction createErrorMessage(ctxt: SchemaContext, message?: string): string {\r\n  const giveValue = JSON.stringify(ctxt.value, (_, value) =>\r\n    typeof value === 'bigint' ? value.toString() : value\r\n  );\r\n  message =\r\n    (message ??\r\n      `Expected value to be of type '${\r\n        ctxt.type\r\n      }' but found '${typeof ctxt.value}'.`) +\r\n    '\\n' +\r\n    `\\nGiven value: ${giveValue}` +\r\n    `\\nType: '${typeof ctxt.value}'` +\r\n    `\\nExpected type: '${ctxt.type}'`;\r\n\r\n  if (ctxt.path.length > 0) {\r\n    const pathString = ctxt.path\r\n      .map(value => objectKeyEncode(value.toString()))\r\n      .join(' â€º ');\r\n    message += `\\nPath: ${pathString}`;\r\n  }\r\n\r\n  return message;\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  isNumericString,\r\n  toValidator,\r\n  coerceNumericStringToNumber,\r\n  coerceStringOrNumberToBigInt,\r\n} from '../utils';\r\n\r\nfunction isValidStringValue(value: unknown): value is string {\r\n  return typeof value === 'string';\r\n}\r\n\r\n/** Create a string schema. */\r\nexport function string(): Schema<string, string> {\r\n  return createSymmetricSchema({\r\n    type: 'string',\r\n    validate: toValidator(isValidStringValue),\r\n    map: identityFn,\r\n  });\r\n}\r\n\r\n/** Create a number schema. */\r\nexport function number(): Schema<number, number> {\r\n  return createSymmetricSchema({\r\n    type: 'number',\r\n    validate: toValidator(isNumericString),\r\n    map: coerceNumericStringToNumber,\r\n  });\r\n}\r\n\r\nfunction isValidBooleanValue(value: unknown): boolean {\r\n  return (\r\n    typeof value === 'boolean' ||\r\n    (typeof value === 'string' && (value === 'true' || value === 'false'))\r\n  );\r\n}\r\n\r\n/** Create a boolean schema. */\r\nexport function boolean(): Schema<boolean, boolean> {\r\n  return createSymmetricSchema({\r\n    type: 'boolean',\r\n    validate: toValidator(isValidBooleanValue),\r\n    map: value => (typeof value === 'boolean' ? value : value === 'true'),\r\n  });\r\n}\r\n\r\nfunction isValidBigIntValue(value: unknown): value is bigint {\r\n  return (\r\n    typeof value === 'bigint' ||\r\n    typeof value === 'number' ||\r\n    (typeof value === 'string' && /^-?\\d+$/.test(value))\r\n  );\r\n}\r\n\r\n/** Create a bigint schema */\r\nexport function bigint(): Schema<bigint, bigint> {\r\n  return createSymmetricSchema({\r\n    type: 'bigint',\r\n    validate: toValidator(isValidBigIntValue),\r\n    map: coerceStringOrNumberToBigInt,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { literalToString } from '../utils';\r\n\r\n/**\r\n * Create a 'defaults' schema.\r\n *\r\n * During mapping or unmapping, if the value is null or undefined, the schema\r\n * defaults to the 'defaultValue' specified in the schema.\r\n */\r\nexport function defaults<M, U, V extends M & U>(\r\n  schema: Schema<M, U>,\r\n  defaultValue: V\r\n): Schema<M, U> {\r\n  return {\r\n    type: () => `Defaults<${schema.type()},${literalToString(defaultValue)}>`,\r\n    validateBeforeMap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeMap(v, ctxt),\r\n    validateBeforeUnmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? [] : schema.validateBeforeUnmap(v, ctxt),\r\n    map: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.map(v, ctxt),\r\n    unmap: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmap(v, ctxt),\r\n    validateBeforeMapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue)\r\n        ? []\r\n        : schema.validateBeforeMapXml(v, ctxt),\r\n    mapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.mapXml(v, ctxt),\r\n    unmapXml: (v, ctxt) =>\r\n      shouldDefault(v, defaultValue) ? defaultValue : schema.unmapXml(v, ctxt),\r\n  };\r\n}\r\n\r\nfunction shouldDefault<T, V extends T>(value: T, defaultValue: V) {\r\n  return value === null || value === undefined || value === defaultValue;\r\n}\r\n","import { Schema, SchemaContextCreator, SchemaValidationError } from '../schema';\r\nimport { objectEntries } from '../utils';\r\n\r\n/**\r\n * Create a dictionary schema.\r\n *\r\n * This can be used to map/unmap a type like Record<string, something>.\r\n */\r\nexport function dict<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const validate = (\r\n    validateFn:\r\n      | 'validateBeforeMap'\r\n      | 'validateBeforeUnmap'\r\n      | 'validateBeforeMapXml',\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as Record<string, unknown>;\r\n    return ctxt.flatmapChildren(\r\n      objectEntries(valueObject),\r\n      itemSchema,\r\n      (v, childCtxt) => itemSchema[validateFn](v[1], childCtxt)\r\n    );\r\n  };\r\n\r\n  return {\r\n    type: () => `Record<string,${itemSchema.type()}>`,\r\n    validateBeforeMap: (...args) => validate('validateBeforeMap', ...args),\r\n    validateBeforeUnmap: (...args) => validate('validateBeforeUnmap', ...args),\r\n    map: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.map(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmap: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmap(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    validateBeforeMapXml: (...args) =>\r\n      validate('validateBeforeMapXml', ...args),\r\n    mapXml: (value, ctxt) => {\r\n      const output: Record<string, T> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.mapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const output: Record<string, S> = {};\r\n      for (const key in value) {\r\n        /* istanbul ignore else */\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propValue = value[key];\r\n          output[key] = itemSchema.unmapXml(\r\n            propValue,\r\n            ctxt.createChild(key, propValue, itemSchema)\r\n          );\r\n        }\r\n      }\r\n      return output;\r\n    },\r\n  };\r\n}\r\n\r\nexport function dictWithXmlEntries<T, S>(\r\n  itemSchema: Schema<T, S>\r\n): Schema<Record<string, T>, Record<string, S>> {\r\n  const dictSchema = dict(itemSchema);\r\n  const modifiedSchema = { ...dictSchema };\r\n\r\n  modifiedSchema.unmapXml = (value, ctxt) => {\r\n    const output: Record<string, S> = dictSchema.unmapXml(value, ctxt);\r\n\r\n    // Convert each entry to XML \"entry\" elements. The XML \"entry\" element looks\r\n    // like this: `<entry key=\"key\">value</entry>`. Note that the element name\r\n    // \"entry\" is set later at the return.\r\n    const entries = objectEntries(output).map(([key, value]) => ({\r\n      $: { key },\r\n      _: value,\r\n    }));\r\n\r\n    return { entry: entries };\r\n  };\r\n\r\n  modifiedSchema.mapXml = (value, ctxt) => {\r\n    // Empty dictionary\r\n    if (!('entry' in value)) {\r\n      return {};\r\n    }\r\n\r\n    let { entry: entries } = value as {\r\n      entry: { $: { key: string }; _: unknown }[];\r\n    };\r\n\r\n    // For a single entry, the XML parser gives a single object instead of an array.\r\n    // Make it an array for easier handling.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Convert entry elements containing a key attribute and content to a dictionary.\r\n    const dictObj: Record<string, unknown> = {};\r\n    for (const item of entries) {\r\n      dictObj[item.$.key] = item._;\r\n    }\r\n\r\n    // Run validation on entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validatin\r\n    return dictSchema.mapXml(dictObj, ctxt);\r\n  };\r\n\r\n  modifiedSchema.validateBeforeMapXml = (value, ctxt) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n\r\n    // Empty dictionary case\r\n    if (!('entry' in value)) {\r\n      return [];\r\n    }\r\n\r\n    let entries = (value as { entry: object[] })['entry'];\r\n\r\n    // Non-repeating XML elements are passed as a single-object instead of an array of objects.\r\n    // We normalize this behavior of the XML parser.\r\n    if (!Array.isArray(entries)) {\r\n      entries = [entries];\r\n    }\r\n\r\n    // Dictionary for all entries\r\n    const dictObj: Record<string, unknown> = {};\r\n\r\n    for (let index = 0; index < entries.length; index++) {\r\n      const entry = entries[index];\r\n      // Fail if entry is not an XML element object.\r\n      if (typeof entry !== 'object' || entry === null) {\r\n        return ctxt.fail('Expected \"entry\" to be an XML element.');\r\n      }\r\n\r\n      // Fail if entry does not have an attribute named key.\r\n      if (!('$' in entry) || !('key' in (entry as { $: object }).$)) {\r\n        return ctxt.fail(\r\n          'Expected \"entry\" element to have an attribute named \"key\".'\r\n        );\r\n      }\r\n\r\n      // Set entry in dictionary\r\n      const typedEntry = entry as { $: { key: string }; _: unknown };\r\n      dictObj[typedEntry.$.key] = typedEntry._;\r\n    }\r\n\r\n    // Check all entry values against the item schema.\r\n    // TODO: Maintain context and path when delegating validation\r\n    return dictSchema.validateBeforeMapXml(dictObj, ctxt);\r\n  };\r\n\r\n  return modifiedSchema;\r\n}\r\n","import {\r\n  Schema,\r\n  SchemaContextCreator,\r\n  SchemaMappedType,\r\n  SchemaType,\r\n  SchemaValidationError,\r\n} from '../schema';\r\nimport { OptionalizeObject } from '../typeUtils';\r\nimport {\r\n  literalToString,\r\n  objectEntries,\r\n  objectKeyEncode,\r\n  omitKeysFromObject,\r\n} from '../utils';\r\n\r\ntype AnyObjectSchema = Record<\r\n  string,\r\n  [string, Schema<any, any>, ObjectXmlOptions?]\r\n>;\r\n\r\ntype AllValues<T extends AnyObjectSchema> = {\r\n  [P in keyof T]: { key: P; value: T[P][0]; schema: T[P][1] };\r\n}[keyof T];\r\n\r\nexport type MappedObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [P in AllValues<T>['value']]: SchemaMappedType<\r\n      Extract<AllValues<T>, { value: P }>['schema']\r\n    >;\r\n  }\r\n>;\r\n\r\nexport type ObjectType<T extends AnyObjectSchema> = OptionalizeObject<\r\n  {\r\n    [K in keyof T]: SchemaType<T[K][1]>;\r\n  }\r\n>;\r\n\r\nexport interface ObjectXmlOptions {\r\n  isAttr?: boolean;\r\n  xmlName?: string;\r\n}\r\n\r\nexport interface StrictObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n> extends Schema<ObjectType<T>, MappedObjectType<T>> {\r\n  readonly objectSchema: T;\r\n}\r\n\r\nexport interface ObjectSchema<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>\r\n  extends Schema<\r\n    ObjectType<T> & { [key: string]: unknown },\r\n    MappedObjectType<T> & { [key: string]: unknown }\r\n  > {\r\n  readonly objectSchema: T;\r\n}\r\n\r\n/**\r\n * Create a Strict Object type schema.\r\n *\r\n * A strict-object does not allow additional properties during mapping or\r\n * unmapping. Additional properties will result in a validation error.\r\n */\r\nexport function strictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, false, false);\r\n  schema.type = () =>\r\n    `StrictObject<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create an Expandable Object type schema.\r\n *\r\n * The object schema allows additional properties during mapping and unmapping. The\r\n * additional properties are copied over as is.\r\n */\r\nexport function expandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): ObjectSchema<V, T> {\r\n  return internalObject(objectSchema, true, true);\r\n}\r\n\r\n/**\r\n * Create an Object Type schema.\r\n *\r\n * The Object schema allows additional properties during mapping and unmapping\r\n * but discards them.\r\n */\r\nexport function object<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(objectSchema: T): StrictObjectSchema<V, T> {\r\n  const schema = internalObject(objectSchema, true, false);\r\n  schema.type = () =>\r\n    `Object<{${Object.keys(objectSchema)\r\n      .map(objectKeyEncode)\r\n      .join(',')}}>`;\r\n  return schema;\r\n}\r\n\r\n/**\r\n * Create a strict-object schema that extends an existing schema.\r\n */\r\nexport function extendStrictObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return strictObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an object schema that extends an existing schema.\r\n */\r\nexport function extendExpandoObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: ObjectSchema<V, T>,\r\n  objectSchema: B\r\n): ObjectSchema<string, T & B> {\r\n  return expandoObject({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Create an Object schema that extends an existing object schema.\r\n */\r\nexport function extendObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>,\r\n  A extends string,\r\n  B extends Record<string, [A, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  parentObjectSchema: StrictObjectSchema<V, T>,\r\n  objectSchema: B\r\n): StrictObjectSchema<string, T & B> {\r\n  return object({ ...parentObjectSchema.objectSchema, ...objectSchema });\r\n}\r\n\r\n/**\r\n * Internal utility to create object schema with different options.\r\n */\r\nfunction internalObject<\r\n  V extends string,\r\n  T extends Record<string, [V, Schema<any, any>, ObjectXmlOptions?]>\r\n>(\r\n  objectSchema: T,\r\n  skipValidateAdditionalProps: boolean,\r\n  mapAdditionalProps: boolean\r\n): StrictObjectSchema<V, T> {\r\n  const keys = Object.keys(objectSchema);\r\n  const reverseObjectSchema = createReverseObjectSchema<T>(objectSchema);\r\n  const xmlMappingInfo = getXmlPropMappingForObjectSchema(objectSchema);\r\n  const xmlObjectSchema = createXmlObjectSchema(objectSchema);\r\n  const reverseXmlObjectSchema = createReverseXmlObjectSchema(xmlObjectSchema);\r\n  return {\r\n    type: () => `Object<{${keys.map(objectKeyEncode).join(',')},...}>`,\r\n    validateBeforeMap: validateObject(\r\n      objectSchema,\r\n      'validateBeforeMap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    validateBeforeUnmap: validateObject(\r\n      reverseObjectSchema,\r\n      'validateBeforeUnmap',\r\n      skipValidateAdditionalProps\r\n    ),\r\n    map: mapObject(objectSchema, 'map', mapAdditionalProps),\r\n    unmap: mapObject(reverseObjectSchema, 'unmap', mapAdditionalProps),\r\n    validateBeforeMapXml: validateObjectBeforeMapXml(\r\n      objectSchema,\r\n      xmlMappingInfo,\r\n      skipValidateAdditionalProps\r\n    ),\r\n    mapXml: mapObjectFromXml(xmlObjectSchema, mapAdditionalProps),\r\n    unmapXml: unmapObjectToXml(reverseXmlObjectSchema, mapAdditionalProps),\r\n    objectSchema: objectSchema,\r\n  };\r\n}\r\n\r\nfunction validateObjectBeforeMapXml(\r\n  objectSchema: Record<string, [string, Schema<any>, ObjectXmlOptions?]>,\r\n  xmlMappingInfo: ReturnType<typeof getXmlPropMappingForObjectSchema>,\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const { elementsToProps, attributesToProps } = xmlMappingInfo;\r\n  return (\r\n    value: unknown,\r\n    ctxt: SchemaContextCreator\r\n  ): SchemaValidationError[] => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    // Validate all known elements and attributes using the schema\r\n    return [\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'child elements',\r\n        propTypePrefix: 'element',\r\n        valueTypeName: 'element',\r\n        propMapping: elementsToProps,\r\n        objectSchema,\r\n        valueObject: elements,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n      ...validateValueObject({\r\n        validationMethod: 'validateBeforeMapXml',\r\n        propTypeName: 'attributes',\r\n        propTypePrefix: '@',\r\n        valueTypeName: 'element',\r\n        propMapping: attributesToProps,\r\n        objectSchema,\r\n        valueObject: attributes,\r\n        ctxt,\r\n        allowAdditionalProperties,\r\n      }),\r\n    ];\r\n  };\r\n}\r\n\r\nfunction mapObjectFromXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(elementsSchema, 'mapXml', allowAdditionalProps);\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'mapXml',\r\n    false // Always false; additional attributes are handled differently below.\r\n  );\r\n\r\n  // These are later used to omit know attribute props from the attributes object\r\n  // so that the remaining props can be copied over as additional props.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const valueObject = value as {\r\n      $?: Record<string, unknown>;\r\n      [key: string]: unknown;\r\n    };\r\n    let { $: attributes, ...elements } = valueObject;\r\n    attributes = attributes ?? {};\r\n\r\n    const output: Record<string, unknown> = {\r\n      ...mapAttributes(attributes, ctxt),\r\n      ...mapElements(elements, ctxt),\r\n    };\r\n\r\n    if (allowAdditionalProps) {\r\n      // Omit known attributes and copy the rest as additional attributes.\r\n      const additionalAttrs = omitKeysFromObject(attributes, attributeKeys);\r\n      if (Object.keys(additionalAttrs).length > 0) {\r\n        // These additional attrs are set in the '$' property by convention.\r\n        output['$'] = additionalAttrs;\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction unmapObjectToXml(\r\n  xmlObjectSchema: XmlObjectSchema,\r\n  allowAdditionalProps: boolean\r\n) {\r\n  const { elementsSchema, attributesSchema } = xmlObjectSchema;\r\n  const mapElements = mapObject(\r\n    elementsSchema,\r\n    'unmapXml',\r\n    allowAdditionalProps\r\n  );\r\n  const mapAttributes = mapObject(\r\n    attributesSchema,\r\n    'unmapXml',\r\n    false // Always false so that element props are not copied during mapping\r\n  );\r\n\r\n  // These are later used to omit attribute props from the value object so that they\r\n  // do not get mapped during element mapping, if the allowAdditionalProps is true.\r\n  const attributeKeys = objectEntries(attributesSchema).map(\r\n    ([_, [name]]) => name\r\n  );\r\n\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    // Get additional attributes which are set in the '$' property by convention\r\n    const { $: attributes, ...rest } = value as {\r\n      $?: unknown;\r\n      [key: string]: unknown;\r\n    };\r\n\r\n    // Ensure 'attributes' is an object and non-null\r\n    const additionalAttributes =\r\n      typeof attributes === 'object' &&\r\n      attributes !== null &&\r\n      allowAdditionalProps\r\n        ? attributes\r\n        : {};\r\n\r\n    return {\r\n      ...mapElements(omitKeysFromObject(rest, attributeKeys), ctxt),\r\n      $: { ...additionalAttributes, ...mapAttributes(value, ctxt) },\r\n    };\r\n  };\r\n}\r\n\r\nfunction validateValueObject({\r\n  validationMethod,\r\n  propTypeName,\r\n  propTypePrefix,\r\n  valueTypeName,\r\n  propMapping,\r\n  objectSchema,\r\n  valueObject,\r\n  ctxt,\r\n  allowAdditionalProperties,\r\n}: {\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml';\r\n  propTypeName: string;\r\n  propTypePrefix: string;\r\n  valueTypeName: string;\r\n  propMapping: Record<string, string>;\r\n  objectSchema: AnyObjectSchema;\r\n  valueObject: { [key: string]: unknown };\r\n  ctxt: SchemaContextCreator;\r\n  allowAdditionalProperties: boolean;\r\n}) {\r\n  const errors: SchemaValidationError[] = [];\r\n  const missingProps: Set<string> = new Set();\r\n  const unknownProps: Set<string> = new Set(Object.keys(valueObject));\r\n\r\n  // Validate all known properties using the schema\r\n  for (const key in propMapping) {\r\n    const propName = propMapping[key];\r\n    const schema = objectSchema[propName][1];\r\n    unknownProps.delete(key);\r\n    if (key in valueObject) {\r\n      errors.push(\r\n        ...schema[validationMethod](\r\n          valueObject[key],\r\n          ctxt.createChild(propTypePrefix + key, valueObject[key], schema)\r\n        )\r\n      );\r\n    } else if (schema.type().indexOf('Optional<') !== 0) {\r\n      // Add to missing keys if it is not an optional property\r\n      missingProps.add(key);\r\n    }\r\n  }\r\n\r\n  // Create validation error for unknown properties encountered\r\n  const unknownPropsArray = Array.from(unknownProps);\r\n  if (unknownPropsArray.length > 0 && !allowAdditionalProperties) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some unknown ${propTypeName} were found in the ${valueTypeName}: ${unknownPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  // Create validation error for missing required properties\r\n  const missingPropsArray = Array.from(missingProps);\r\n  if (missingPropsArray.length > 0) {\r\n    errors.push(\r\n      ...ctxt.fail(\r\n        `Some ${propTypeName} are missing in the ${valueTypeName}: ${missingPropsArray\r\n          .map(literalToString)\r\n          .join(', ')}.`\r\n      )\r\n    );\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nfunction validateObject(\r\n  objectSchema: AnyObjectSchema,\r\n  validationMethod:\r\n    | 'validateBeforeMap'\r\n    | 'validateBeforeUnmap'\r\n    | 'validateBeforeMapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  const propsMapping = getPropMappingForObjectSchema(objectSchema);\r\n  return (value: unknown, ctxt: SchemaContextCreator) => {\r\n    if (typeof value !== 'object' || value === null) {\r\n      return ctxt.fail();\r\n    }\r\n    return validateValueObject({\r\n      validationMethod,\r\n      propTypeName: 'properties',\r\n      propTypePrefix: '',\r\n      valueTypeName: 'object',\r\n      propMapping: propsMapping,\r\n      objectSchema,\r\n      valueObject: value as Record<string, unknown>,\r\n      ctxt,\r\n      allowAdditionalProperties,\r\n    });\r\n  };\r\n}\r\n\r\nfunction mapObject<T extends AnyObjectSchema>(\r\n  objectSchema: T,\r\n  mappingFn: 'map' | 'unmap' | 'mapXml' | 'unmapXml',\r\n  allowAdditionalProperties: boolean\r\n) {\r\n  return (value: unknown, ctxt: SchemaContextCreator): any => {\r\n    const output: Record<string, unknown> = {};\r\n    const objectValue = value as Record<string, any>;\r\n    /** Properties seen in the object but not in the schema */\r\n    const unknownKeys = new Set(Object.keys(objectValue));\r\n\r\n    // Map known properties using the schema\r\n    for (const key in objectSchema) {\r\n      /* istanbul ignore else */\r\n      if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n        const element = objectSchema[key];\r\n        const propName = element[0];\r\n        const propValue = objectValue[propName];\r\n        unknownKeys.delete(propName);\r\n\r\n        // Skip mapping for optional properties to avoid creating properties with value 'undefined'\r\n        if (\r\n          element[1].type().indexOf('Optional<') !== 0 ||\r\n          propValue !== undefined\r\n        ) {\r\n          output[key] = element[1][mappingFn](\r\n            propValue,\r\n            ctxt.createChild(propName, propValue, element[1])\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Copy unknown properties over if additional properties flag is set\r\n    if (allowAdditionalProperties) {\r\n      unknownKeys.forEach(unknownKey => {\r\n        output[unknownKey] = objectValue[unknownKey];\r\n      });\r\n    }\r\n    return output;\r\n  };\r\n}\r\n\r\nfunction getXmlPropMappingForObjectSchema(objectSchema: AnyObjectSchema) {\r\n  const elementsToProps: Record<string, string> = {};\r\n  const attributesToProps: Record<string, string> = {};\r\n\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const [propName, , xmlOptions] = objectSchema[key];\r\n      if (xmlOptions?.isAttr === true) {\r\n        attributesToProps[xmlOptions.xmlName ?? propName] = key;\r\n      } else {\r\n        elementsToProps[xmlOptions?.xmlName ?? propName] = key;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { elementsToProps, attributesToProps };\r\n}\r\n\r\nfunction getPropMappingForObjectSchema(\r\n  objectSchema: AnyObjectSchema\r\n): Record<string, string> {\r\n  const propsMapping: Record<string, string> = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const propDef = objectSchema[key];\r\n      propsMapping[propDef[0]] = key;\r\n    }\r\n  }\r\n  return propsMapping;\r\n}\r\n\r\nfunction createReverseObjectSchema<T extends AnyObjectSchema>(\r\n  objectSchema: T\r\n): AnyObjectSchema {\r\n  const reverseObjectSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      reverseObjectSchema[element[0]] = [key, element[1], element[2]];\r\n    }\r\n  }\r\n  return reverseObjectSchema;\r\n}\r\n\r\ntype XmlObjectSchema = {\r\n  elementsSchema: AnyObjectSchema;\r\n  attributesSchema: AnyObjectSchema;\r\n};\r\n\r\nfunction createXmlObjectSchema(objectSchema: AnyObjectSchema): XmlObjectSchema {\r\n  const elementsSchema: AnyObjectSchema = {};\r\n  const attributesSchema: AnyObjectSchema = {};\r\n  for (const key in objectSchema) {\r\n    /* istanbul ignore else */\r\n    if (Object.prototype.hasOwnProperty.call(objectSchema, key)) {\r\n      const element = objectSchema[key];\r\n      const [serializedName, schema, xmlOptions] = element;\r\n      const xmlObjectSchema = xmlOptions?.isAttr\r\n        ? attributesSchema\r\n        : elementsSchema;\r\n      xmlObjectSchema[key] = [\r\n        xmlOptions?.xmlName ?? serializedName,\r\n        schema,\r\n        xmlOptions,\r\n      ];\r\n    }\r\n  }\r\n  return { elementsSchema, attributesSchema };\r\n}\r\n\r\nfunction createReverseXmlObjectSchema(\r\n  xmlObjectSchema: XmlObjectSchema\r\n): XmlObjectSchema {\r\n  return {\r\n    attributesSchema: createReverseObjectSchema(\r\n      xmlObjectSchema.attributesSchema\r\n    ),\r\n    elementsSchema: createReverseObjectSchema(xmlObjectSchema.elementsSchema),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { arrayEntries } from '../utils';\r\n\r\nexport interface ArrayXmlOptions {\r\n  xmlItemName: string;\r\n}\r\n\r\n/**\r\n * Create an array schema.\r\n *\r\n * The array must be a homogenous array confirming to the itemsSchema. Each item\r\n * will be mapped/unmapped using the itemsSchema.\r\n */\r\nexport function array<T, S>(\r\n  itemsSchema: Schema<T, S>,\r\n  xmlOptions?: ArrayXmlOptions\r\n): Schema<T[], S[]> {\r\n  let arraySchema: Schema<T[], S[]>;\r\n  arraySchema = {\r\n    type: () => `Array<${itemsSchema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      Array.isArray(value)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(value),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeUnmap(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail(),\r\n    map: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.map(v[1], childCtxt)\r\n      ),\r\n    unmap: (value, ctxt) =>\r\n      ctxt.mapChildren(arrayEntries(value), itemsSchema, (v, childCtxt) =>\r\n        itemsSchema.unmap(v[1], childCtxt)\r\n      ),\r\n    mapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        items = value[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n      return ctxt.mapChildren(\r\n        arrayEntries(items as any[]),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.mapXml(v[1], childCtxt)\r\n      );\r\n    },\r\n    unmapXml: (value, ctxt) => {\r\n      const items = ctxt.mapChildren(\r\n        arrayEntries(value),\r\n        itemsSchema,\r\n        (v, childCtxt) => itemsSchema.unmapXml(v[1], childCtxt)\r\n      );\r\n      if (xmlOptions?.xmlItemName) {\r\n        return { [xmlOptions.xmlItemName]: items };\r\n      } else {\r\n        return items;\r\n      }\r\n    },\r\n    validateBeforeMapXml: (value, ctxt) => {\r\n      let items = value;\r\n      if (xmlOptions?.xmlItemName) {\r\n        const errorMessage = `Expected array to be wrapped with XML element ${xmlOptions.xmlItemName}.`;\r\n        if (\r\n          typeof value !== 'object' ||\r\n          value === null ||\r\n          !(xmlOptions.xmlItemName in value)\r\n        ) {\r\n          return ctxt.fail(errorMessage);\r\n        }\r\n        items = (value as Record<string, unknown>)[xmlOptions.xmlItemName];\r\n        ctxt = ctxt.createChild(xmlOptions.xmlItemName, items, itemsSchema);\r\n      }\r\n\r\n      return Array.isArray(items)\r\n        ? ctxt.flatmapChildren(\r\n            arrayEntries(items),\r\n            itemsSchema,\r\n            (v, childCtxt) => itemsSchema.validateBeforeMapXml(v[1], childCtxt)\r\n          )\r\n        : ctxt.fail();\r\n    },\r\n  };\r\n  return arraySchema;\r\n}\r\n","import { Schema, SchemaMappedType, SchemaType } from '../schema';\r\nimport { objectEntries } from '../utils';\r\nimport { ObjectXmlOptions } from './object';\r\n\r\nexport function discriminatedObject<\r\n  TSchema extends Schema<any, any>,\r\n  TDiscrimProp extends keyof SchemaType<TSchema>,\r\n  TDiscrimMappedProp extends keyof SchemaMappedType<TSchema>,\r\n  TDiscrimMap extends Record<string, TSchema>\r\n>(\r\n  discriminatorMappedPropName: TDiscrimMappedProp,\r\n  discriminatorPropName: TDiscrimProp,\r\n  discriminatorMap: TDiscrimMap,\r\n  defaultDiscriminator: keyof TDiscrimMap,\r\n  xmlOptions?: ObjectXmlOptions\r\n): Schema<any, any> {\r\n  const schemaSelector = (\r\n    value: unknown,\r\n    discriminatorProp: string | TDiscrimProp | TDiscrimMappedProp,\r\n    isAttr: boolean = false\r\n  ) => {\r\n    if (\r\n      typeof value === 'object' &&\r\n      value !== null &&\r\n      ((isAttr && xmlObjectHasAttribute(value, discriminatorProp as string)) ||\r\n        (!isAttr && (discriminatorProp as string) in value))\r\n    ) {\r\n      const discriminatorValue = isAttr\r\n        ? (value as { $: Record<string, unknown> })['$'][\r\n            discriminatorProp as string\r\n          ]\r\n        : (value as Record<typeof discriminatorProp, unknown>)[\r\n            discriminatorProp\r\n          ];\r\n      if (\r\n        typeof discriminatorValue === 'string' &&\r\n        discriminatorValue in discriminatorMap\r\n      ) {\r\n        return discriminatorMap[discriminatorValue];\r\n      }\r\n    }\r\n    return discriminatorMap[defaultDiscriminator];\r\n  };\r\n  return {\r\n    type: () =>\r\n      `DiscriminatedUnion<${discriminatorPropName},[${objectEntries(\r\n        discriminatorMap\r\n      )\r\n        .map(([_, v]) => v.type)\r\n        .join(',')}]>`,\r\n    map: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmap(value, ctxt),\r\n    validateBeforeMap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorPropName).validateBeforeMap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).validateBeforeUnmap(\r\n        value,\r\n        ctxt\r\n      ),\r\n    mapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      schemaSelector(value, discriminatorMappedPropName).unmapXml(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      schemaSelector(\r\n        value,\r\n        xmlOptions?.xmlName ?? discriminatorPropName,\r\n        xmlOptions?.isAttr\r\n      ).validateBeforeMapXml(value, ctxt),\r\n  };\r\n}\r\n\r\nfunction xmlObjectHasAttribute(value: object, prop: string): boolean {\r\n  return (\r\n    '$' in value &&\r\n    typeof (value as { $: unknown })['$'] === 'object' &&\r\n    (prop as string) in (value as { $: Record<string, unknown> })['$']\r\n  );\r\n}\r\n","import { Schema } from '../schema';\r\nimport { once } from '../utils';\r\n\r\n/**\r\n * Create a schema that lazily delegates to the given schema.\r\n */\r\nexport function lazy<T, V>(schemaFn: () => Schema<T, V>): Schema<T, V> {\r\n  const getSchema = once(schemaFn); // Memoize schema\r\n  return {\r\n    type: () => `Lazy<${getSchema().type()}>`,\r\n    map: (...args) => getSchema().map(...args),\r\n    unmap: (...args) => getSchema().unmap(...args),\r\n    validateBeforeMap: (...args) => getSchema().validateBeforeMap(...args),\r\n    validateBeforeUnmap: (...args) => getSchema().validateBeforeUnmap(...args),\r\n    mapXml: (...args) => getSchema().mapXml(...args),\r\n    unmapXml: (...args) => getSchema().unmapXml(...args),\r\n    validateBeforeMapXml: (...args) =>\r\n      getSchema().validateBeforeMapXml(...args),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, literalToString, toValidator } from '../utils';\r\n\r\n/**\r\n * Create a literal schema.\r\n *\r\n * This schema always unmaps/maps to the constant value provided in the schema,\r\n * regardless of the value being mapped/unmapped. The validation always passes.\r\n */\r\nexport function literal<T extends boolean>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends number>(literalValue: T): Schema<T, T>;\r\nexport function literal<T extends string>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T>;\r\nexport function literal<T>(literalValue: T): Schema<T, T> {\r\n  const validate = (value: unknown): value is T => literalValue === value;\r\n  const map = () => literalValue;\r\n  return createSymmetricSchema({\r\n    type: `Literal<${literalToString(literalValue)}>`,\r\n    validate: toValidator(validate),\r\n    map: map,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Creates a nullable schema.\r\n *\r\n * The nullable schema allows null values or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function nullable<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | null, S | null> {\r\n  return {\r\n    type: () => `Nullable<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) => (value === null ? null : schema.map(value, ctxt)),\r\n    unmap: (value, ctxt) => (value === null ? null : schema.unmap(value, ctxt)),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === null ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === null ? null : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === null ? null : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  coerceNumericStringToNumber,\r\n  createSymmetricSchema,\r\n  isNumericString,\r\n  toValidator,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    isNumericString(value) &&\r\n    enumValues.includes(coerceNumericStringToNumber(value));\r\n}\r\n\r\n/**\r\n * Create a schema for a number enumeration.\r\n */\r\nexport function numberEnum<T extends string, TEnumValue extends number>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .filter(v => typeof v === 'number')\r\n      .join(',')}>`,\r\n    map: coerceNumericStringToNumber as (value: unknown) => TEnumValue,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\n\r\n/**\r\n * Create an optional schema.\r\n *\r\n * The optional schema allows 'undefined' or the values allowed by the given\r\n * 'schema'.\r\n */\r\nexport function optional<T, S>(\r\n  schema: Schema<T, S>\r\n): Schema<T | undefined, S | undefined> {\r\n  return {\r\n    type: () => `Optional<${schema.type()}>`,\r\n    validateBeforeMap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMap(value, ctxt),\r\n    validateBeforeUnmap: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeUnmap(value, ctxt),\r\n    map: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.map(value, ctxt),\r\n    unmap: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmap(value, ctxt),\r\n    validateBeforeMapXml: (value, ctxt) =>\r\n      value === undefined ? [] : schema.validateBeforeMapXml(value, ctxt),\r\n    mapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.mapXml(value, ctxt),\r\n    unmapXml: (value, ctxt) =>\r\n      value === undefined ? undefined : schema.unmapXml(value, ctxt),\r\n  };\r\n}\r\n","import { Schema } from '../schema';\r\nimport {\r\n  toValidator,\r\n  createSymmetricSchema,\r\n  identityFn,\r\n  literalToString,\r\n} from '../utils';\r\n\r\nfunction createEnumChecker<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n) {\r\n  const enumValues = Object.values(enumVariable);\r\n  return (value: unknown): value is TEnumValue =>\r\n    typeof value === 'string' && enumValues.includes(value);\r\n}\r\n\r\n/**\r\n * Create a schema for a string enumeration.\r\n */\r\nexport function stringEnum<T extends string, TEnumValue extends string>(\r\n  enumVariable: { [key in T]: TEnumValue }\r\n): Schema<TEnumValue, TEnumValue> {\r\n  const validate = toValidator(createEnumChecker(enumVariable));\r\n\r\n  return createSymmetricSchema({\r\n    type: `Enum<${Object.values(enumVariable)\r\n      .map(literalToString)\r\n      .join(',')}>`,\r\n    map: identityFn,\r\n    validate: validate,\r\n  });\r\n}\r\n","import { Schema } from '../schema';\r\nimport { createSymmetricSchema, identityFn } from '../utils';\r\n\r\n/**\r\n * Create an unknown schema.\r\n *\r\n * The unknown schema allows any value.\r\n */\r\nexport function unknown(): Schema<unknown, unknown> {\r\n  return createSymmetricSchema({\r\n    type: 'unknown',\r\n    validate: () => [],\r\n    map: identityFn,\r\n  });\r\n}\r\n"],"names":["arrayEntries","arr","entries","index","length","push","objectEntries","obj","ownProps","Object","keys","i","resArray","Array","literalToString","value","replace","identityFn","toValidator","fn","ctxt","fail","createSymmetricSchema","schema","basicSchema","type","validateBeforeMap","validate","validateBeforeUnmap","map","unmap","validateBeforeMapXml","mapXml","unmapXml","isNumericString","isNaN","coerceNumericStringToNumber","coerceStringOrNumberToBigInt","BigInt","omitKeysFromObject","object","keysToOmit","omitSet","Set","output","key","prototype","hasOwnProperty","call","has","objectKeyEncode","indexOf","createNewSchemaContext","branch","path","createSchemaContextCreator","currentContext","createChildContext","childSchema","mapChildren","items","itemSchema","mapper","item","createChild","flatmapChildren","flatten","message","createErrorMessage","giveValue","JSON","stringify","_","toString","join","isValidStringValue","isValidBooleanValue","isValidBigIntValue","test","shouldDefault","defaultValue","dict","validateFn","v","childCtxt","args","propValue","strictObject","objectSchema","internalObject","expandoObject","skipValidateAdditionalProps","mapAdditionalProps","reverseObjectSchema","createReverseObjectSchema","xmlMappingInfo","elementsToProps","attributesToProps","propName","xmlOptions","isAttr","xmlName","getXmlPropMappingForObjectSchema","xmlObjectSchema","elementsSchema","attributesSchema","element","createXmlObjectSchema","reverseXmlObjectSchema","createReverseXmlObjectSchema","validateObject","mapObject","validateObjectBeforeMapXml","mapObjectFromXml","unmapObjectToXml","allowAdditionalProperties","attributes","$","elements","validateValueObject","validationMethod","propTypeName","propTypePrefix","valueTypeName","propMapping","valueObject","allowAdditionalProps","mapElements","mapAttributes","attributeKeys","additionalAttrs","rest","additionalAttributes","errors","missingProps","unknownProps","add","unknownPropsArray","from","missingPropsArray","propsMapping","getPropMappingForObjectSchema","mappingFn","objectValue","unknownKeys","undefined","forEach","unknownKey","itemsSchema","isArray","xmlItemName","dictSchema","modifiedSchema","entry","dictObj","discriminatorMappedPropName","discriminatorPropName","discriminatorMap","defaultDiscriminator","schemaSelector","discriminatorProp","prop","xmlObjectHasAttribute","discriminatorValue","parentObjectSchema","schemaFn","func","memo","ran","getSchema","apply","this","literalValue","enumVariable","enumValues","values","includes","createEnumChecker","filter","contextCreator","validationResult","result"],"mappings":"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"}